/*! jQuery Sticker - v0.6.8 - 2014-09-06
* https://github.com/amazingSurge/jquery-sticker
* Copyright (c) 2014 amazingSurge; Licensed GPL */
(function(window, document, $, undefined) {
    "use strict";

    var $window = $(window),
        windowHeight = $window.height();

    var Global = {
        count: 0,
        started: false,
        instances: [],
        types: {},
        generateId: function() {
            this.count++;
            return this.count;
        },
        scroll: function() {
            $.each(Global.instances, function(i, instance) {
                if (instance.enabled) {
                    Global.types[instance.type].scroll(instance);

                    // fire custom scroll callback
                    if ($.isFunction(instance.options.scroll)) {
                        instance.options.scroll.call(instance);
                    }
                }
            });
        },
        resize: function() {
            windowHeight = $window.height();

            $.each(Global.instances, function(i, instance) {
                if (instance.enabled) {
                    Global.types[instance.type].resize(instance);
                    Global.types[instance.type].scroll(instance);

                    // fire custom resize callback
                    if ($.isFunction(instance.options.resize)) {
                        instance.options.resize.call(instance);
                    }
                }
            });
        },
        start: function(throttle) {
            if (!this.started) {
                $window.on('scroll.sticker', Global.throttle(this.scroll, throttle));
                $window.on('orientationchange.sticker resize.sticker', Global.throttle(this.resize, throttle));
                this.started = true;
            }
        },
        stop: function() {
            this.started = false;
            $window.off('.sticker');
        },
        /**
         * throttle
         * @description Borrowed from Underscore.js
         */
        throttle: function(func, wait) {
            var _now = Date.now || function() {
                return new Date().getTime();
            };
            var context, args, result;
            var timeout = null;
            var previous = 0;
            var later = function() {
                previous = _now();
                timeout = null;
                result = func.apply(context, args);
                context = args = null;
            };
            return function() {
                var now = _now();
                var remaining = wait - (now - previous);
                context = this;
                args = arguments;
                if (remaining <= 0) {
                    clearTimeout(timeout);
                    timeout = null;
                    previous = now;
                    result = func.apply(context, args);
                    context = args = null;
                } else if (!timeout) {
                    timeout = setTimeout(later, remaining);
                }
                return result;
            };
        }
    };

    // Constructor
    var Sticker = $.Sticker = function(element, options) {
        this.element = element;
        this.$element = $(element);

        // Get the type
        this.type = (options.type !== undefined) ? options.type : Sticker.defaults.type;
        // Merge the options
        this.options = $.extend({}, Sticker.defaults, Global.types[this.type].defaults, options);

        this.enabled = false;
        this.sticky = false;

        // Namespacing
        var namespace = this.options.namespace;

        // Class
        this.classes = {};
        this.classes.wrapper = namespace + '-wrapper';
        this.classes.enabled = namespace + '_enabled';
        this.classes.sticky = namespace + '_sticky';

        this.components = {};

        // Initialization
        this.init();
    };

    // Default options for the plugin as a simple object
    Sticker.defaults = {
        namespace: 'sticker', // String: Prefix string attached to the class of every element generated by the plugin,
        type: 'top', // String: Select your sticky type, "top", "bottom", "fill" or "sidebar"
        throttle: '250',

        // Callback API
        init: null, // Callback: function() - Fires when init
        destroy: null, // Callback: function() - Fires when destroy
        scroll: null, // Callback: function() - Fires when scroll
        resize: null, // Callback: function() - Fires when resize
        enable: null, // Callback: function() - Fires when enable sticky
        disable: null, // Callback: function() - Fires when disable sticky
        sticky: null, // Callback: function() - Fires when sticky
        unsticky: null // Callback: function() - Fires when unsticky
    };

    Sticker.registerType = function(name, type) {
        Global.types[name] = type;
    };

    Sticker.prototype = {
        constructor: Sticker,
        init: function() {
            this.id = Global.generateId();

            var $wrapper = $('<div></div>').addClass(this.classes.wrapper);

            var id = this.$element.attr('id');

            if (typeof id !== 'undefined') {
                $wrapper.attr('id', id + '-' + this.options.namespace + '-wrapper');
            }

            this.$element.wrapAll($wrapper);
            this.$wrapper = this.$element.parent();

            //initial type
            Global.types[this.type].init(this);

            // fire custom init callback
            if ($.isFunction(this.options.init)) {
                this.options.init.call(this);
            }
            this.enable();

            Global.instances.push(this);
            Global.start(this.options.throttle);

        },
        destroy: function() {
            this.$element.unwrap();

            for (var i in Global.instances) {
                if (Global.instances[i].id === this.id) {
                    Global.instances.splice(i, 1);
                }
            }

            if (Global.instances.length === 0) {
                Global.stop();
            }

            if ($.isFunction(this.options.destroy)) {
                this.options.destroy.call(this);
            }
        },
        enable: function() {
            this.enabled = true;
            Global.types[this.type].enable(this);
            this.$wrapper.addClass(this.classes.enabled);
            Global.types[this.type].scroll(this);

            // fire custom enable callback
            if ($.isFunction(this.options.enable)) {
                this.options.enable.call(this);
            }
        },
        disable: function() {
            this.enabled = false;
            this.sticky = false;
            Global.types[this.type].disable(this);
            this.$wrapper.removeClass(this.classes.sticky).removeClass(this.classes.enabled);

            // fire custom disable callback
            if ($.isFunction(this.options.disable)) {
                this.options.disable.call(this);
            }
        },
        on: function(e, callback) {
            if (typeof e === "string" && typeof callback === "function") {
                this.options[e] = callback;
            }
        },
        off: function(e) {
            if (typeof e === "string") {
                this.options[e] = null;
            }
        },
        set: function(option, value) {
            this.options[option] = value;
        },
        update: function() {
            if (this.enabled) {
                Global.types[this.type].scroll(this);
            }
        }
    };

    Sticker.registerType('top', {
        defaults: {
            topSpace: 0
        },
        init: function(api) {},
        scroll: function(api) {
            // in this case, the element should not have margin top and bottom value
            var scrollTop = $window.scrollTop(),
                elementTop = api.$wrapper.offset().top,
                topSpace = api.options.topSpace;
            if (topSpace > elementTop && elementTop >= 0) {
                topSpace = elementTop;
            }

            var extra = elementTop - topSpace - scrollTop;
            if (extra < 0) {
                if (!api.sticky) {
                    api.sticky = true;
                    api.$wrapper.addClass(api.classes.sticky);
                    api.$element.css({
                        position: 'fixed',
                        top: topSpace
                    });
                    // fire custom sticky callback
                    if ($.isFunction(api.options.sticky)) {
                        api.options.sticky.call(api);
                    }
                }
            } else {
                if (api.sticky) {
                    api.sticky = false;
                    api.$wrapper.removeClass(api.classes.sticky);
                    api.$element.css({
                        position: '',
                        top: ''
                    });
                    // fire custom unsticky callback
                    if ($.isFunction(api.options.unsticky)) {
                        api.options.unsticky.call(api);
                    }
                }
            }
        },
        resize: function(api) {
            api.$wrapper.css('height', api.$element.outerHeight(true));
        },
        enable: function(api) {
            api.$wrapper.css('height', api.$element.outerHeight(true));
        },
        disable: function(api) {
            api.$element.css({
                position: '',
                top: ''
            });
            api.$wrapper.css('height', '');
        }
    });
    Sticker.registerType('fill', {
        defaults: {
            useFlex: true,
            check: true,
            callback: null // Callback: function(api) - Fires when fill,
        },
        init: function(api) {
            if (!api.options.useFlex || !this.vhSupport() || !this.flexSupport()) {
                api.options.useFlex = false;
            }

            api.paddingBottom = parseInt(api.$element.css("padding-bottom"), 10);
        },
        scroll: function(api) {
            if (api.options.useFlex) {
                return;
            }

            var scrollTop = $window.scrollTop(),
                documentHeight = $('body').height();

            if (scrollTop === 0 && documentHeight <= windowHeight) {
                if (!api.sticky) {
                    api.sticky = true;
                    api.$wrapper.addClass(api.classes.sticky);
                    api.$element.css("padding-bottom", windowHeight - documentHeight + api.paddingBottom);
                    // fire custom sticky callback
                    if ($.isFunction(api.options.sticky)) {
                        api.options.sticky.call(api);
                    }
                }
            } else {
                if (api.sticky) {
                    api.sticky = false;
                    api.$wrapper.removeClass(api.classes.sticky);
                    api.$element.css("padding-bottom", '');
                    // fire custom unsticky callback
                    if ($.isFunction(api.options.unsticky)) {
                        api.options.unsticky.call(api);
                    }
                }
            }

            // fire custom callback
            if ($.isFunction(api.options.callback)) {
                api.options.callback.call(api, scrollTop, documentHeight, windowHeight);
            }
        },
        resize: function(api) {
            if (api.options.useFlex) {
                return;
            }

            api.$element.css("padding-bottom", '');
            api.paddingBottom = parseInt(api.$element.css("padding-bottom"), 10);
            api.sticky = false;
        },
        enable: function(api) {
            if (api.options.useFlex) {
                api.$wrapper.parent().addClass(api.options.namespace + '_fill-container');
                api.$wrapper.addClass(api.options.namespace + '_fill');
            } else {
                if (api.options.check) {
                    var original = $('body').height();
                    api.checkInterval = setInterval(function() {
                        if (original !== $('body').height()) {
                            Global.types[api.type].scroll(api);
                            original = $('body').height();
                        }
                    }, 500);
                }
            }
        },
        disable: function(api) {
            if (api.options.useFlex) {
                api.$wrapper.parent().removeClass(api.options.namespace + '-fill-container');
                api.$wrapper.removeClass(api.options.namespace + '-fill');
            } else {
                if (api.options.check) {
                    clearInterval(api.checkInterval);
                }
                api.$element.css("padding-bottom", '');
            }
        },
        flexSupport: function() {
            var b = document.body || document.documentElement,
                s = b.style,
                t = 'boxDirection';

            if (typeof s[t] === 'string') {
                return true;
            }
            var browsers = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];
            t = t.charAt(0).toUpperCase() + t.substr(1);
            for (var i = 0; i < browsers.length; i++) {
                if (typeof s[browsers[i] + t] === 'string') {
                    return true;
                }
            }
            return false;
        },
        vhSupport: function() {
            var $elem = $('<div style="height:50vh;visibility:hidden;" />').appendTo('body'),
                height = parseInt(window.innerHeight / 2, 10),
                compStyle = parseInt((window.getComputedStyle ?
                    window.getComputedStyle($elem.get(0), null) :
                    $elem.get(0).currentStyle)["height"], 10);
            $elem.remove();
            return compStyle === height;
        }
    });

    Sticker.registerType('sidebar', {
        defaults: {
            topSpace: 0, // how many pixels to pad the element from the top of the window
            bottom: null, // Callback: function() - Fires when bottom
            unbottom: null // Callback: function() - Fires when unbottom
        },
        init: function(api) {

        },
        scroll: function(api) {
            var topSpace = api.options.topSpace,
                scrollTop = $window.scrollTop() + topSpace,
                elementHeight = api.$element.outerHeight(),
                parentHeight = api.$parent.height(),
                borderTop = parseInt(api.$parent.css("border-top-width"), 10),
                paddingTop = parseInt(api.$parent.css("padding-top"), 10),
                parentTop = api.$parent.offset().top + borderTop + paddingTop,
                elementTop = api.$element.offset().top - parseInt(api.$element.css("padding-top"), 10),
                willBottom, paddingBottom;

            if (!api.sticky && scrollTop > elementTop) {
                api.sticky = true;
                api.$wrapper.addClass(api.classes.sticky);
                api.$element.css({
                    position: 'fixed',
                    top: topSpace
                });

                // fire custom unsticky callback
                if ($.isFunction(api.options.sticky)) {
                    api.options.sticky.call(api);
                }
            } else if (api.sticky) {
                if (scrollTop < parentTop) {
                    api.sticky = false;
                    api.$wrapper.removeClass(api.classes.sticky);
                    api.$element.css({
                        position: '',
                        top: '',
                        bottom: ''
                    });

                    // fire custom unsticky callback
                    if ($.isFunction(api.options.unsticky)) {
                        api.options.unsticky.call(api);
                    }
                } else {
                    willBottom = scrollTop + elementHeight > parentHeight + parentTop;
                    if (willBottom) {
                        api.bottomed = true;
                        paddingBottom = parseInt(api.$parent.css("padding-bottom"), 10);

                        api.$element.css({
                            position: "absolute",
                            top: '',
                            bottom: paddingBottom
                        });

                        // fire custom bottom callback
                        if ($.isFunction(api.options.bottom)) {
                            api.options.bottom.call(api);
                        }
                    } else if (api.bottomed) {
                        api.bottomed = false;

                        api.$element.css({
                            position: 'fixed',
                            bottom: '',
                            top: topSpace
                        });
                        // fire custom unbottom callback
                        if ($.isFunction(api.options.unbottom)) {
                            api.options.unbottom.call(api);
                        }
                    }
                }
            }
        },
        resize: function(api) {

        },
        enable: function(api) {
            var elementHeight = api.$element.outerHeight(),
                elementWidth = api.$element.outerWidth(true),
                float = api.$element.css("float"),
                display = api.$element.css("display"),
                verticalAlign = api.$element.css("vertical-align");

            // if (float == 'none') {
            // 	api.$element.width(api.$element.width());
            // }
            api.$wrapper.css({
                width: elementWidth,
                height: elementHeight,
                display: display,
                "vertical-align": verticalAlign,
                float: float
            });

            api.$parent = api.$wrapper.parent();
            api.$parent.css('position', 'relative');

            api.bottomed = false;
            api.sticky = false;
        },
        disable: function(api) {
            api.$wrapper.css({
                width: '',
                height: '',
                display: '',
                "vertical-align": '',
                float: ''
            });
            api.$element.css({
                position: '',
                top: ''
            });
        }
    });

    // Collection method.
    $.fn.sticker = function(options) {
        if (typeof options === 'string') {
            var method = options;
            var method_arguments = Array.prototype.slice.call(arguments, 1);

            return this.each(function() {
                var api = $.data(this, 'sticker');

                if (api && typeof api[method] === 'function') {
                    api[method].apply(api, method_arguments);
                }
            });
        } else {
            return this.each(function() {
                if (!$.data(this, 'sticker')) {
                    $.data(this, 'sticker', new Sticker(this, options));
                }
            });
        }
    };
}(window, document, jQuery));
